# -*- coding: utf-8 -*-
"""DSFM_India&China.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G1j-Xrk50caIXVzVr9oc9QGXQhrYo832
"""

from google.colab import drive
drive.mount('/content/drive')

import yfinance as yf
import pandas as pd
import datetime

# Define the indices and their ticker symbols
tickers = {
    "BSE Sensex": "^BSESN",  # BSE Sensex ticker
    "SSE Composite": "000001.SS"  # SSE Composite ticker
}

# Define the start and end dates
start_date = "2004-04-01"
end_date = "2012-03-31"

# Create an empty DataFrame to store closing prices
closing_prices = pd.DataFrame()

# Download data for each ticker
for name, ticker in tickers.items():
    print(f"Downloading data for {name} ({ticker})...")
    data = yf.download(ticker, start=start_date, end=end_date)
    closing_prices[name] = data["Close"]

# Format the index to display only the date
closing_prices.index = closing_prices.index.date

# Reset the index to include the date as a column with the name 'Date'
closing_prices.reset_index(inplace=True)
closing_prices.rename(columns={"index": "Date"}, inplace=True)

# Define the file path
file_path = "/content/drive/MyDrive/DSFM_India&China/indices_closing_prices.csv"

# Save to CSV file
closing_prices.to_csv(file_path, index=False)

print(f"Closing prices saved to {file_path}")

import pandas as pd

# Load the daily closing prices CSV file
file_path = "/content/drive/MyDrive/DSFM_India&China/indices_closing_prices.csv"
daily_closing_prices = pd.read_csv(file_path, parse_dates=["Date"])

# Set 'Date' as the index for resampling
daily_closing_prices.set_index("Date", inplace=True)

# Resample to monthly data and take the last closing price of each month
monthly_closing_prices = daily_closing_prices.resample("M").last()

# Reset the index to include 'Date' as a column
monthly_closing_prices.reset_index(inplace=True)

# Save the monthly closing prices to a new CSV file
monthly_file_path = "/content/drive/MyDrive/DSFM_India&China/indices_monthly_closing_prices.csv"
monthly_closing_prices.to_csv(monthly_file_path, index=False)

print(f"Monthly closing prices saved to {monthly_file_path}")

import pandas as pd
import numpy as np

# Load the monthly closing prices CSV file
monthly_file_path = "/content/drive/MyDrive/DSFM_India&China/indices_monthly_closing_prices.csv"
monthly_closing_prices = pd.read_csv(monthly_file_path, parse_dates=["Date"])

# Calculate logarithmic returns
returns = pd.DataFrame()
returns["Date"] = monthly_closing_prices["Date"]  # Retain the Date column

# Compute logarithmic returns for each index
for column in monthly_closing_prices.columns[1:]:  # Exclude 'Date' column
    prices = monthly_closing_prices[column]
    log_returns = (np.log(prices) - np.log(prices.shift(1))) * 100
    returns[column] = log_returns

# Drop the first row as it will have NaN values due to the shift
returns.dropna(inplace=True)

# Save the returns to a new CSV file
returns_file_path = "/content/drive/MyDrive/DSFM_India&China/indices_monthly_returns.csv"
returns.to_csv(returns_file_path, index=False)

print(f"Monthly returns saved to {returns_file_path}")

import pandas as pd
import numpy as np

# Load the CSV file containing the monthly returns data
data = pd.read_csv('/content/drive/MyDrive/DSFM_India&China/indices_monthly_returns.csv')

# Convert the 'Date' column to datetime to filter by specific year range
data['Date'] = pd.to_datetime(data['Date'])

# Filter the data for the period May 2004 to March 2005
data_filtered = data[(data['Date'] >= '2004-05-01') & (data['Date'] <= '2005-03-31')]

# Extract the returns column (assuming the column name is 'Return')
returns = data_filtered['BSE Sensex']

# Initialize an empty list to store monthly volatilities
monthly_volatility = []

# Loop through each month and calculate volatility (standard deviation) for the returns up to that month
for i in range(1, len(returns) + 1):
    # Calculate standard deviation for the first i months (cumulative standard deviation)
    volatility = np.std(returns[:i])
    monthly_volatility.append(volatility)

# Add the volatility values to the dataframe for better visualization
data_filtered['Monthly Volatility'] = monthly_volatility

# Display the data with monthly volatility
print(data_filtered[['Date', 'BSE Sensex', 'Monthly Volatility']])

import pandas as pd
import numpy as np

# Load the monthly closing prices CSV file
monthly_file_path = "/content/drive/MyDrive/DSFM_India&China/indices_closing_prices.csv"
monthly_closing_prices = pd.read_csv(monthly_file_path, parse_dates=["Date"])

# Calculate logarithmic returns
returns = pd.DataFrame()
returns["Date"] = monthly_closing_prices["Date"]  # Retain the Date column

# Compute logarithmic returns for each index
for column in monthly_closing_prices.columns[1:]:  # Exclude 'Date' column
    prices = monthly_closing_prices[column]
    log_returns = (np.log(prices) - np.log(prices.shift(1))) * 100
    returns[column] = log_returns

# Drop the first row as it will have NaN values due to the shift
returns.dropna(inplace=True)

# Save the returns to a new CSV file
returns_file_path = "/content/drive/MyDrive/DSFM_India&China/indices_daily_returns.csv"
returns.to_csv(returns_file_path, index=False)

print(f"Monthly returns saved to {returns_file_path}")

import pandas as pd
import numpy as np

# Step 1: Load the data
data = pd.read_csv('/content/drive/MyDrive/DSFM_India&China/indices_daily_returns.csv')  # Replace with your CSV file name
data['Date'] = pd.to_datetime(data['Date'])  # Ensure 'Date' is in datetime format

# Step 2: Filter data for April 2004 to March 2005
filtered_data = data[(data['Date'] >= '2004-04-01') & (data['Date'] <= '2005-03-31')]

# Step 3: Add a 'Year-Month' column for grouping
filtered_data['Year-Month'] = filtered_data['Date'].dt.to_period('M')

# Step 4: Calculate monthly volatility
monthly_volatility = (
    filtered_data.groupby('Year-Month')['BSE Sensex']
    .std()  # Standard deviation of daily returns
    .reset_index()
)
monthly_volatility.rename(columns={'Daily_Return': 'Monthly_Volatility'}, inplace=True)

# Step 5: Save or display results
print(monthly_volatility)
monthly_volatility.to_csv('monthly_volatility_2004_2005.csv', index=False)  # Save to CSV

import pandas as pd
import numpy as np

# Step 1: Load the data
data = pd.read_csv('/content/drive/MyDrive/DSFM_India&China/indices_daily_returns.csv')  # Replace with your CSV file name
data['Date'] = pd.to_datetime(data['Date'])  # Ensure 'Date' is in datetime format

# Step 2: Filter data for April 2004 to March 2005
filtered_data = data[(data['Date'] >= '2004-04-01') & (data['Date'] <= '2005-03-31')]

# Step 3: Add a 'Year-Month' column for grouping
filtered_data['Year-Month'] = filtered_data['Date'].dt.to_period('M')

# Step 4: Calculate monthly volatility
monthly_volatility = (
    filtered_data.groupby('Year-Month')['SSE Composite']
    .std()  # Standard deviation of daily returns
    .reset_index()
)
monthly_volatility.rename(columns={'Daily_Return': 'Monthly_Volatility'}, inplace=True)

# Step 5: Save or display results
print(monthly_volatility)
monthly_volatility.to_csv('monthly_volatility_china_2004_2005.csv', index=False)  # Save to CSV

import pandas as pd
import matplotlib.pyplot as plt

def plot_monthly_volatility(data_path, start_date, end_date, save_path):
    """
    Plots and saves a graph of monthly volatility for BSE Sensex and SSE Composite over a given time period.

    Parameters:
    - data_path (str): Path to the CSV file containing the data.
    - start_date (str): Start date of the time period in 'YYYY-MM-DD' format.
    - end_date (str): End date of the time period in 'YYYY-MM-DD' format.
    - save_path (str): Path to save the generated graph image.
    """
    # Load the data
    data = pd.read_csv(data_path)
    data['Date'] = pd.to_datetime(data['Date'])  # Ensure 'Date' is in datetime format

    # Filter data for the specified time period
    filtered_data = data[(data['Date'] >= start_date) & (data['Date'] <= end_date)]

    # Add a 'Year-Month' column for grouping
    filtered_data['Year-Month'] = filtered_data['Date'].dt.to_period('M')

    # Calculate monthly volatility for BSE and SSE
    bse_volatility = (
        filtered_data.groupby('Year-Month')['BSE Sensex']
        .std()  # Standard deviation of daily returns for BSE Sensex
        .reset_index()
    )
    sse_volatility = (
        filtered_data.groupby('Year-Month')['SSE Composite']
        .std()  # Standard deviation of daily returns for SSE Composite
        .reset_index()
    )

    # Rename columns for clarity
    bse_volatility.rename(columns={'BSE Sensex': 'Monthly_Volatility'}, inplace=True)
    sse_volatility.rename(columns={'SSE Composite': 'Monthly_Volatility'}, inplace=True)

    # Convert 'Year-Month' column to string for plotting
    bse_volatility['Year-Month'] = bse_volatility['Year-Month'].astype(str)
    sse_volatility['Year-Month'] = sse_volatility['Year-Month'].astype(str)

    # Plot the data
    plt.figure(figsize=(10, 6))
    plt.plot(bse_volatility['Year-Month'], bse_volatility['Monthly_Volatility'], label='BSE Sensex', color='blue', linestyle='solid')
    plt.plot(sse_volatility['Year-Month'], sse_volatility['Monthly_Volatility'], label='SSE Composite', color='green', linestyle='dotted')

    # Customize the graph
    plt.xlabel('Month', fontsize=12)
    plt.ylabel('Monthly Volatility', fontsize=12)
    plt.title(f'Monthly Volatility ({start_date} to {end_date})', fontsize=14)
    plt.xticks(rotation=45, fontsize=10)
    plt.legend()
    plt.grid(True)

    # Save the graph
    plt.tight_layout()
    plt.savefig(save_path)
    plt.show()

# Example usage
plot_monthly_volatility(
    data_path='/content/drive/MyDrive/DSFM_India&China/indices_daily_returns.csv',
    start_date='2004-04-01',
    end_date='2005-03-31',
    save_path='/content/drive/MyDrive/DSFM_India&China/monthly_volatility_apr2004_mar2005.png'
)

# Example usage
plot_monthly_volatility(
    data_path='/content/drive/MyDrive/DSFM_India&China/indices_daily_returns.csv',
    start_date='2005-04-01',
    end_date='2006-03-31',
    save_path='/content/drive/MyDrive/DSFM_India&China/monthly_volatility_apr2011_mar2012.png'
)

# Example usage
plot_monthly_volatility(
    data_path='/content/drive/MyDrive/DSFM_India&China/indices_daily_returns.csv',
    start_date='2006-04-01',
    end_date='2007-03-31',
    save_path='/content/drive/MyDrive/DSFM_India&China/monthly_volatility_apr2011_mar2012.png'
)

# Example usage
plot_monthly_volatility(
    data_path='/content/drive/MyDrive/DSFM_India&China/indices_daily_returns.csv',
    start_date='2007-04-01',
    end_date='2008-03-31',
    save_path='/content/drive/MyDrive/DSFM_India&China/monthly_volatility_apr2011_mar2012.png'
)

# Example usage
plot_monthly_volatility(
    data_path='/content/drive/MyDrive/DSFM_India&China/indices_daily_returns.csv',
    start_date='2008-04-01',
    end_date='2009-03-31',
    save_path='/content/drive/MyDrive/DSFM_India&China/monthly_volatility_apr2011_mar2012.png'
)

plot_monthly_volatility(
    data_path='/content/drive/MyDrive/DSFM_India&China/indices_daily_returns.csv',
    start_date='2009-04-01',
    end_date='2010-03-31',
    save_path='/content/drive/MyDrive/DSFM_India&China/monthly_volatility_apr2011_mar2012.png'
)

plot_monthly_volatility(
    data_path='/content/drive/MyDrive/DSFM_India&China/indices_daily_returns.csv',
    start_date='2010-04-01',
    end_date='2011-03-31',
    save_path='/content/drive/MyDrive/DSFM_India&China/monthly_volatility_apr2011_mar2012.png'
)

plot_monthly_volatility(
    data_path='/content/drive/MyDrive/DSFM_India&China/indices_daily_returns.csv',
    start_date='2011-04-01',
    end_date='2012-03-31',
    save_path='/content/drive/MyDrive/DSFM_India&China/monthly_volatility_apr2011_mar2012.png'
)

!pip install arch

# Install the arch package if you haven't already
!pip install arch

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from arch import arch_model

# Step 1: Load the data
data = pd.read_csv('/content/drive/MyDrive/DSFM_India&China/indices_daily_returns.csv')  # Replace with your file path
data['Date'] = pd.to_datetime(data['Date'])  # Ensure 'Date' is in datetime format

# Step 2: Filter data for April 2011 to March 2012
filtered_data = data[(data['Date'] >= '2011-04-01') & (data['Date'] <= '2012-03-31')]

# Step 3: Select the BSE Sensex and SSE Composite return values
bse_returns = filtered_data['BSE Sensex'].dropna()  # Remove NaN values if any
sse_returns = filtered_data['SSE Composite'].dropna()  # Remove NaN values if any

# Step 4: Initialize and fit GARCH(1,1) models for both indices
bse_model = arch_model(bse_returns, vol='Garch', p=1, q=1, mean='Constant', dist='normal')
sse_model = arch_model(sse_returns, vol='Garch', p=1, q=1, mean='Constant', dist='normal')

bse_fit = bse_model.fit(disp='off')  # Fit the BSE model
sse_fit = sse_model.fit(disp='off')  # Fit the SSE model

# Print the summary of both models
print("BSE GARCH Model Summary:")
print(bse_fit.summary())
print("\nSSE GARCH Model Summary:")
print(sse_fit.summary())

# Step 5: Get conditional volatility
bse_volatility = bse_fit.conditional_volatility
sse_volatility = sse_fit.conditional_volatility

# Step 6: Forecast volatility for the next 5 days
bse_forecast = bse_fit.forecast(horizon=5, reindex=False)
sse_forecast = sse_fit.forecast(horizon=5, reindex=False)

# Forecasted variance (converted to volatility by taking square root)
bse_forecast_volatility = np.sqrt(bse_forecast.variance.iloc[-1])
sse_forecast_volatility = np.sqrt(sse_forecast.variance.iloc[-1])

print("\nForecasted Volatility for the next 5 days (BSE Sensex):")
print(bse_forecast_volatility)
print("\nForecasted Volatility for the next 5 days (SSE Composite):")
print(sse_forecast_volatility)

# Step 7: Plot conditional volatility
plt.figure(figsize=(12, 6))
plt.plot(filtered_data['Date'], bse_volatility, label='BSE Sensex Volatility', color='blue')
plt.plot(filtered_data['Date'], sse_volatility, label='SSE Composite Volatility', color='green')
plt.title('Conditional Volatility from GARCH(1,1)', fontsize=14)
plt.xlabel('Date', fontsize=12)
plt.ylabel('Volatility', fontsize=12)
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.show()

# Step 8: Save the plot
plt.savefig('/content/drive/MyDrive/DSFM_India&China/garch_volatility_comparison.png')

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from arch import arch_model

# Step 1: Load the data
data = pd.read_csv('/content/drive/MyDrive/DSFM_India&China/indices_daily_returns.csv')  # Replace with your file path
data['Date'] = pd.to_datetime(data['Date'])  # Ensure 'Date' is in datetime format

# Step 2: Filter data for April 2011 to March 2012
filtered_data = data[(data['Date'] >= '2011-04-01') & (data['Date'] <= '2012-03-31')]

# Step 3: Select the BSE Sensex and SSE Composite return values
bse_returns = filtered_data['BSE Sensex'].dropna()  # Remove NaN values if any
sse_returns = filtered_data['SSE Composite'].dropna()  # Remove NaN values if any

# Step 4: Initialize and fit GARCH(1,1) models for both indices
bse_model = arch_model(bse_returns, vol='Garch', p=1, q=1, mean='Constant', dist='normal')
sse_model = arch_model(sse_returns, vol='Garch', p=1, q=1, mean='Constant', dist='normal')

bse_fit = bse_model.fit(disp='off')  # Fit the BSE model
sse_fit = sse_model.fit(disp='off')  # Fit the SSE model

# Step 5: Get conditional volatility
bse_volatility = bse_fit.conditional_volatility
sse_volatility = sse_fit.conditional_volatility

# Step 6: Forecast volatility for the next 5 days
bse_forecast = bse_fit.forecast(horizon=5, reindex=False)
sse_forecast = sse_fit.forecast(horizon=5, reindex=False)

# Append forecasted values to conditional volatility
forecast_dates = pd.date_range(filtered_data['Date'].iloc[-1], periods=6, freq='B')[1:]  # Generate next 5 business days
bse_forecast_volatility = np.sqrt(bse_forecast.variance.iloc[-1])
sse_forecast_volatility = np.sqrt(sse_forecast.variance.iloc[-1])

bse_volatility_extended = np.concatenate([bse_volatility, bse_forecast_volatility])
sse_volatility_extended = np.concatenate([sse_volatility, sse_forecast_volatility])

dates_extended = filtered_data['Date'].tolist() + forecast_dates.tolist()

# Step 7: Plot past and predicted volatility
plt.figure(figsize=(12, 6))
plt.plot(dates_extended, bse_volatility_extended, label='BSE Sensex Volatility', color='blue', linestyle='solid')
plt.plot(dates_extended, sse_volatility_extended, label='SSE Composite Volatility', color='green', linestyle='dotted')
plt.axvline(x=filtered_data['Date'].iloc[-1], color='red', linestyle='--', label='Forecast Start')
plt.title('Past and Predicted Volatility (GARCH Model)', fontsize=14)
plt.xlabel('Date', fontsize=12)
plt.ylabel('Volatility', fontsize=12)
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.show()

# Save the plot
plt.savefig('/content/drive/MyDrive/DSFM_India&China/garch_volatility_with_forecast.png')

"""Rolling Correlation Plot, Engle-Granger Results"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import coint
from statsmodels.tsa.api import adfuller
from statsmodels.tsa.vector_ar.vecm import coint_johansen

def analyze_correlation_and_cointegration(data, start_date, end_date, rolling_window=30):
    """
    This function analyzes the rolling correlation and performs cointegration analysis
    between BSE Sensex and SSE Composite for a specified date range.

    Parameters:
    - data (pd.DataFrame): The dataset containing the returns of the two indices.
    - start_date (str): The start date for the analysis (format: 'YYYY-MM-DD').
    - end_date (str): The end date for the analysis (format: 'YYYY-MM-DD').
    - rolling_window (int): The rolling window size for the correlation calculation. Default is 30 days.

    Returns:
    - None (Displays plots and prints the cointegration test results).
    """
    # Filter data for the specified time period
    filtered_data = data.loc[start_date:end_date]

    # Extract returns for the two indices
    bse_returns = filtered_data['BSE Sensex']
    sse_returns = filtered_data['SSE Composite']

    # Rolling Correlation
    rolling_corr = bse_returns.rolling(window=rolling_window).corr(sse_returns)

    # Plot Rolling Correlation
    plt.figure(figsize=(10, 6))
    plt.plot(rolling_corr, label=f'Rolling Correlation ({rolling_window} Days)', color='purple')
    plt.title(f'Rolling Correlation between BSE Sensex and SSE Composite\n({start_date} to {end_date})', fontsize=14)
    plt.xlabel('Date', fontsize=12)
    plt.ylabel('Correlation', fontsize=12)
    plt.axhline(0, color='black', linewidth=1, linestyle='dashed')
    plt.legend()
    plt.grid(True)
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

    # Cointegration Analysis - Engle-Granger Test
    coint_t, p_value, crit_value = coint(bse_returns, sse_returns)
    print("Engle-Granger Cointegration Test Results:")
    print(f"T-statistic: {coint_t}")
    print(f"P-value: {p_value}")
    print(f"Critical Values: {crit_value}")

    if p_value < 0.05:
        print("The indices are cointegrated (Reject null hypothesis of no cointegration).")
    else:
        print("The indices are NOT cointegrated (Fail to reject null hypothesis).")

# Load the data
data = pd.read_csv('/content/drive/MyDrive/DSFM_India&China/indices_daily_returns.csv')
data['Date'] = pd.to_datetime(data['Date'])
data.set_index('Date', inplace=True)

# Call the function with a specific date range
analyze_correlation_and_cointegration(data, '2004-04-01', '2005-03-31')

# Call the function with a specific date range
analyze_correlation_and_cointegration(data, '2005-04-01', '2006-03-31')

# Call the function with a specific date range
analyze_correlation_and_cointegration(data, '2006-04-01', '2007-03-31')

# Call the function with a specific date range
analyze_correlation_and_cointegration(data, '2007-04-01', '2008-03-31')

# Call the function with a specific date range
analyze_correlation_and_cointegration(data, '2008-04-01', '2009-03-31')

# Call the function with a specific date range
analyze_correlation_and_cointegration(data, '2009-04-01', '2010-03-31')

# Call the function with a specific date range
analyze_correlation_and_cointegration(data, '2010-04-01', '2011-03-31')

# Call the function with a specific date range
analyze_correlation_and_cointegration(data, '2011-04-01', '2012-03-31')

